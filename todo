1. UTCTime をそのまま Field の instance にしているが、本当は newtype で
	くくってからのほうが望ましい。あとでやること
2. mAB を完成させること
	今のやりかたでうまくいきそうである
	気をつける点は padding だ
	4 byte 境界でない場合にそれを考慮する必要がある
	とりあえず B 曲線の数は出力チャネルの数に等しいということ
3. 今は String を使っているが、最終的には ByteString を使った設計にする
4. mod を使えるようにする必要がある
5. サイズが自分で決まるタイプの要素にはサイズを自己申告するようにしたい
	そのためには全ての要素にサイズのフィールドをいれるべきかもしれない
6. チェックのために、ファイルパスのリストを取って、そのファイル達の
	フォルダを test/iccps/ から test/iccps/out/ へと変えたファイルに書き出す
	プログラムを作ろう。
	というか、readICCP2 をそういう仕様に変えよう
7. s15Fixed16Number, u8Fixed8Number 等をちゃんと Fixed に変換するようにしよう
	読み込み時にしてしまっていいかもしれない
8. data MAB = MAB {
	i :: ...,
	o :: ...,
	b_curvs :: ...}
	のようにするべきだろう。
9. curvs を curves にしたほうが良いかもしれない
10. offset による読み込みを、[binary| ... |] のなかにいれる
11. binary-file で [binary-select| ... |] を作ろう
12. 10 のためにまずは、モデルを作ろう
	上記モデルはまず先頭に名前(4文字ASCII)、offset、size のリストを取り、
	それに続けて実際のデータの領域が続く。
	また、データの領域の先頭は型名(4文字ASCII) とし、その後に4byte の 0 があり、
	その後に実際のデータがあるという形とする。
	4byte 領域となるように padding もする。
	型はとりあえず asci と wrd8 としよう。
	前者は String として取り、後者は [Word8] として取る。
13. File.Binary.Instances.MSB0 と File.Binary.Instances.LSB0 を作ろう。
	これらは bigendian や littleendian とは独立しているようなので。
14. [a] の FieldArgument は [arg] にしたほうがいいのかもしれない。
	ただ、足りなかった場合に error が出せないのが問題。
	そこは ([arg], Bool) で足りなかった場合に error を出すかどうか決めるのが
	良いかと。
	あるいは足りなかったときには error を出さないでスルーするのもありか。
	そうすると今まで ((), Just n) と書いていた部分は replicate n () となる。
	また、((), Nothing) と書いていた部分は repeat () となるだろう。
15. 上記の変更はわりと大幅な変更になるな。
