1. UTCTime をそのまま Field の instance にしているが、本当は newtype で
	くくってからのほうが望ましい。あとでやること
2. mAB を完成させること
	今のやりかたでうまくいきそうである
	気をつける点は padding だ
	4 byte 境界でない場合にそれを考慮する必要がある
	とりあえず B 曲線の数は出力チャネルの数に等しいということ
3. 今は String を使っているが、最終的には ByteString を使った設計にする
4. mod を使えるようにする必要がある
5. サイズが自分で決まるタイプの要素にはサイズを自己申告するようにしたい
	そのためには全ての要素にサイズのフィールドをいれるべきかもしれない
6. チェックのために、ファイルパスのリストを取って、そのファイル達の
	フォルダを test/iccps/ から test/iccps/out/ へと変えたファイルに書き出す
	プログラムを作ろう。
	というか、readICCP2 をそういう仕様に変えよう
7. s15Fixed16Number, u8Fixed8Number 等をちゃんと Fixed に変換するようにしよう
	読み込み時にしてしまっていいかもしれない
8. data MAB = MAB {
	i :: ...,
	o :: ...,
	b_curvs :: ...}
	のようにするべきだろう。
9. curvs を curves にしたほうが良いかもしれない
10. offset による読み込みを、[binary| ... |] のなかにいれる
11. binary-file で [binary-select| ... |] を作ろう
12. 10 のためにまずは、モデルを作ろう
	上記モデルはまず先頭に名前(4文字ASCII)、offset、size のリストを取り、
	それに続けて実際のデータの領域が続く。
	また、データの領域の先頭は型名(4文字ASCII) とし、その後に4byte の 0 があり、
	その後に実際のデータがあるという形とする。
	4byte 領域となるように padding もする。
	型はとりあえず asci と wrd8 としよう。
	前者は String として取り、後者は [Word8] として取る。
	同じデータを別のデータとして読み書きできるようにするために、
	また、データの並びとタグの並びとを独立させるために、
	sort して nubBy で offset の共通しているものを消す。
	nubBy だとたとえば size が違った場合に問題が出る。
	しかし offset が同じで size が違うというのはちょっとやりすぎ感がある。
	だから offset が同じで size が同じ場合のみを考慮し、
	それ以外で領域に重なりまたはすきまがある場合は error とする。
	つまり、offset で sort した常態で check をしよう。
	4 byte padding を考慮したうえで offset が連続している場合のみを許す。
